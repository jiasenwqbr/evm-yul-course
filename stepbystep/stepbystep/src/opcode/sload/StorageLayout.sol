// // SPDX-License-Identifier: UNLICENSED
 pragma solidity ^0.8.13;

// contract StorageLayout {
//     // 存储槽 0
//     uint256 public value1 = 0x1111111111111111;
//     // 存储槽 1  
//     address public owner = 0x742d35Cc6634C0532925a3b8Dc23846f1cE8C7d3;
//     // 存储槽 2 (bool 只使用1字节，但占用整个存储槽)
//     bool public isActive = true;
//     // 存储槽 3,4,5 (每个 uint128 占用16字节，所以两个可以打包在一个存储槽)
//     uint128 public a = 0xAAAA;
//     uint128 public b = 0xBBBB;
//     // 存储槽 keccak256(0) 开始
//     mapping(uint => uint) public myMap;
//     // 存储槽 6
//     bytes32 public data = 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF;
// }

// /**
 
// 1. SLOAD 操作码概述
//     操作码： 0x54
//     气体消耗：
//     冷读取：2,100 gas（首次访问）
//     热读取：100 gas（同一交易内再次访问）
//     *根据 EIP-2929 引入的冷热存储访问模式*
//     栈输入： 1 个元素：key - 要读取的存储槽位置（32字节）
//     栈输出： 1 个元素：value - 从存储槽读取的值（32字节）
//     功能： 从合约的持久化存储中读取指定存储槽的值。

// 2. 核心概念与设计目的
//     EVM存储是一个持久的、键值对形式的存储空间，在区块链上永久保存。与内存和栈不同，存储数据在交易结束后依然存在。
//     SLOAD 的核心目的是从持久化存储中读取状态变量。它是访问合约状态的唯一方式。
//     关键特性：
//         持久性：存储数据在区块链上永久保存
//         高Gas成本：读取和写入存储都非常昂贵
//         256位值：每个存储槽存储32字节（256位）数据
//         键值对：存储是简单的 key-value 映射
//         冷热访问：EIP-2929 引入了访问状态的概念以优化Gas

// 3. 底层工作原理
//     EVM存储是一个巨大的 key-value 存储，其中 key 和 value 都是32字节：
//     存储布局：
//         每个合约有自己的独立存储空间
//         存储槽从 0 开始顺序编号（但编译器可能优化布局）
//         使用 keccak256 哈希进行动态数据结构的存储
//     执行过程：
//         SLOAD 从栈顶弹出 key（存储槽位置）
//         检查该存储槽是否在当前交易中被访问过
//         如果是首次访问（冷读取），消耗 2,100 gas
//         如果已访问过（热读取），消耗 100 gas
//         从存储中读取对应 key 的32字节值
//         将值压入栈顶
//  */