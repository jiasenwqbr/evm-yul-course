// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract PopExample1 {
    // 一个返回数字但可能也执行了某些逻辑的函数
    function doSomething() public pure returns (uint256) {
        return 42;
    }

    function callAndIgnoreReturn() public  {
        // 我们调用 doSomething，但不想使用它的返回值
        // 在高级Solidity中，直接调用而不赋值即可。
        doSomething(); // 编译器会自动处理返回值

        // 但是，在汇编层面，我们需要手动 POP
        assembly {
            // 调用 doSomething
            let success := call(gas(), sload(0), 0, 0, 0, 0, 0)
            // 此时，如果调用成功，返回值会被放在栈顶
            // 因为我们不关心这个返回值，所以将其弹出
            pop(success) // 弹出调用是否成功的标志
            // 注意：这里我们甚至没有去取返回值，只弹出了success标志。
            // 如果函数有返回值，它也会在栈上，需要另外处理。
        }
    }
} 


/**
 1. POP 操作码概述
    操作码： 0x50
    气体消耗： 2 gas（基础费用）
    栈输入： 1 个元素（任何值）
    栈输出： 0 个元素（即，栈顶元素被移除）
    功能： 从EVM执行栈的顶部移除（弹出）一个元素。

2. 核心概念与设计目的
    EVM是一个基于栈的虚拟机，所有计算都在一个后进先出（LIFO）的栈上进行。操作码从栈上获取参数，并将结果压入栈中。这个栈的深度最大为1024个元素。
    POP 操作码的核心目的是管理栈空间。在执行过程中，栈上可能会留下一些不再需要的中间值或临时结果。如果不及时清理，可能会导致栈溢出（超过1024的限制）或逻辑混乱。POP 就是用来清理这些“栈垃圾”的工具。

常见使用场景：
    忽略函数的返回值：当你调用一个函数，但它返回一个你不需要的值时，你可以用 POP 将其从栈顶移除。
    清理计算中间值：在复杂的计算过程中，某些中间步骤的结果在后续步骤中不再需要。
    在条件分支后统一栈深度：为了确保不同执行路径（如 if-else 语句）结束后栈的深度一致，有时需要在分支内使用 POP 来移除不需要的值。

3. 底层工作原理
    从硬件的角度看，EVM栈是一个在内存中维护的结构。它有一个“栈指针”，指向当前栈顶的位置。
    当执行 PUSH 操作时，栈指针增加，数据被写入新的栈顶。
    当执行 POP 操作时，栈指针简单地减少。EVM并不会去“擦除”那个位置的数据，它只是标记该位置为可覆盖。下一次 PUSH 操作会直接覆盖掉原来的值。
    所以，POP 是一个非常高效的操作，它只涉及一个简单的指针递减。

 */


/**
 
call 指令的参数含义（EVM 原语）
call(gas(), sload(0), 0, 0, 0, 0, 0) 对应 EVM CALL 操作，参数与含义（按顺序）：
    gas() —— 提供给被调用合约的 gas 数量（这里传入当前剩余 gas）。
    sload(0) —— 被调用目标地址（EVM 在 call 中把这个 256-bit 值的低 160 位当作地址）。
    0 —— 传递的以太币数量（value，单位 wei）。这里是 0。
    0 —— 输入数据在内存中的偏移（in offset）。这里是 0 表示从内存地址 0 开始读输入数据。
    0 —— 输入数据长度（in size）。0 表示没有输入数据发送给被调用方。
    0 —— 输出数据要写到内存的偏移（out offset）。0 表示将返回数据写到内存 0（如果 outsize > 0 的话）。
    0 —— 输出数据长度（out size）。0 表示不把返回数据拷到内存（即不保存返回结果到 memory）。
    call(...) 返回一个布尔（0 或 1）到栈上，表示调用是否成功（1 = 成功，0 = 失败 / revert / OOG 等）。
 */